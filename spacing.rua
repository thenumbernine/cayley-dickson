#!/usr/bin/env rua
--[[
print all spacings of 7-mobius-strips in 15x15 grid such that all pairs of mobius strips share 3 elements in common

args: spacing.lua m n p [all] [showmatrix]


spacings of 3-sets in 7x7 grid such that all pairs of 3-sets share 3 elements in common
1 2 . 3 . .  .
. 2 5 . 7 .  .
. . 5 3 . 6  .
. . . 3 7 . -4
1 . . . 7 6  .
. 2 . . . 6 -4
1 . 5 . . . -4


here are the findings:
m n p:
0, 0, 2 order #1		. .
0, 1, 2 order #1	0	x .
2, 2, 2 order #1	0 1	x x
0, 0, 3 order #1		. . .
0, 1, 3 order #1	0	x . .
1, 2, 3 order #1	0 1	x x .
3, 3, 3 order #1	0 1 2	x x x
0, 0, 4 order #1		. . . .
0, 1, 4 order #1	0	x . . .
2, 3, 4 order #1	0 1 2	x x x .
4, 4, 4 order #1	0 1 2 3	x x x x
0, 0, 5 order #1		. . . . .
0, 1, 5 order #1	0	x . . . .
3, 4, 5 order #1	0 1 2 3	x x x x .
5, 5, 5 order #1	0 1 2 3 4	x x x x x
0, 0, 6 order #1		. . . . . .
0, 1, 6 order #1	0	x . . . . .
4, 5, 6 order #1	0 1 2 3 4	x x x x x .
6, 6, 6 order #1	0 1 2 3 4 5	x x x x x x
0, 0, 7 order #1		. . . . . . .
0, 1, 7 order #1	0	x . . . . . .
1, 3, 7 order #1	0 1 3	x x . x . . .
2, 4, 7 order #1	0 1 2 4	x x x . x . .
5, 6, 7 order #1	0 1 2 3 4 5	x x x x x x .
7, 7, 7 order #1	0 1 2 3 4 5 6	x x x x x x x
0, 0, 8 order #1		. . . . . . . .
0, 1, 8 order #1	0	x . . . . . . .
6, 7, 8 order #1	0 1 2 3 4 5 6	x x x x x x x .
8, 8, 8 order #1	0 1 2 3 4 5 6 7	x x x x x x x x
0, 0, 9 order #1		. . . . . . . . .
0, 1, 9 order #1	0	x . . . . . . . .
7, 8, 9 order #1	0 1 2 3 4 5 6 7	x x x x x x x x .
9, 9, 9 order #1	0 1 2 3 4 5 6 7 8	x x x x x x x x x
0, 0, 10 order #1		. . . . . . . . . .
0, 1, 10 order #1	0	x . . . . . . . . .
8, 9, 10 order #1	0 1 2 3 4 5 6 7 8	x x x x x x x x x .
10, 10, 10 order #1	0 1 2 3 4 5 6 7 8 9	x x x x x x x x x x
0, 0, 11 order #1		. . . . . . . . . . .
0, 1, 11 order #1	0	x . . . . . . . . . .
2, 5, 11 order #1	0 1 2 4 7	x x x . x . . x . . .
3, 6, 11 order #1	0 1 2 4 5 7	x x x . x x . x . . .
9, 10, 11 order #1	0 1 2 3 4 5 6 7 8 9	x x x x x x x x x x .
11, 11, 11 order #1	0 1 2 3 4 5 6 7 8 9 10	x x x x x x x x x x x
0, 0, 12 order #1		. . . . . . . . . . . .
0, 1, 12 order #1	0	x . . . . . . . . . . .
10, 11, 12 order #1	0 1 2 3 4 5 6 7 8 9 10	x x x x x x x x x x x .
12, 12, 12 order #1	0 1 2 3 4 5 6 7 8 9 10 11	x x x x x x x x x x x x
0, 0, 13 order #1		. . . . . . . . . . . . .
0, 1, 13 order #1	0	x . . . . . . . . . . . .
1, 4, 13 order #1	0 1 3 9	x x . x . . . . . x . . .
6, 9, 13 order #1	0 1 2 3 4 5 7 9 10	x x x x x x . x . x x . .
11, 12, 13 order #1	0 1 2 3 4 5 6 7 8 9 10 11	x x x x x x x x x x x x .
13, 13, 13 order #1	0 1 2 3 4 5 6 7 8 9 10 11 12	x x x x x x x x x x x x x
0, 0, 14 order #1		. . . . . . . . . . . . . .
0, 1, 14 order #1	0	x . . . . . . . . . . . . .
12, 13, 14 order #1	0 1 2 3 4 5 6 7 8 9 10 11 12	x x x x x x x x x x x x x .
14, 14, 14 order #1	0 1 2 3 4 5 6 7 8 9 10 11 12 13	x x x x x x x x x x x x x x
0, 0, 15 order #1		. . . . . . . . . . . . . . .
0, 1, 15 order #1	0	x . . . . . . . . . . . . . .
3, 7, 15 order #1	0 1 2 4 5 8 10	x x x . x x . . x . x . . . .
4, 8, 15 order #1	0 1 2 3 5 7 8 11	x x x x . x . x x . . x . . .
13, 14, 15 order #1	0 1 2 3 4 5 6 7 8 9 10 11 12 13	x x x x x x x x x x x x x x .
15, 15, 15 order #1	0 1 2 3 4 5 6 7 8 9 10 11 12 13 14	x x x x x x x x x x x x x x x

--]]
local matrix = require 'matrix'
local mod1 = |x, p| ((x-1) % p + 1)		-- modulo of 1-based indexes

local allSoFar = table()

local m = tonumber(cmdline[2]) or 1
local n = tonumber(cmdline[3]) or 3
local p = tonumber(cmdline[4]) or 7
local once = not cmdline.all
local showmatrix = not not cmdline.showmatrix

--[=[ sedenions in 32-ions
local m = 7
local n = 15
local p = 31
--]=]
--[=[ octonions in sedenions
local m = 3		-- number of elements in common
local n = 7		-- size of subset to look for
local p = 15	-- size of space to scan
--]=]
--[=[ quaternions in octonions
local m = 1
local n = 3
local p = 7
--]=]

local check = matrix.lambda({p,p}, |i,j| i==j and n or m)

local o = range(n):mapi(|| 0)
local omax = range(n):mapi(|i| i == 1 and 0 or p-1)	-- constrian our 1st iterator to 0 only to cut down on isomorphisms
while true do
	local offsets = table(o)
	if showmatrix then print(offsets:unpack()) end
	local M = matrix.zeros(p,p)
	for i=1,p do
		for _,j in ipairs(offsets) do
			M[i][mod1(i + j, p)] = 1
		end
	end
	local N = M * M:transpose()
	if showmatrix then
		print(M)
		print(N)
	end
	if N == check then
		local expanded = range(p):mapi(|i| offsets:find(i-1) and 'x' or '.')

		local found = allSoFar:find(nil, |sofar|do
			for shift=0,p-1 do
				local shifted = range(p):mapi(|i|
					expanded[(i-1+shift) % p + 1]
				):concat()
				if shifted == sofar.expanded:concat() then return true end
			end
		end)
		local foundRev = not found and allSoFar:find(nil, |sofar|do
			for shift=0,p-1 do
				local shifted = range(p):reverse():mapi(|i|
					expanded[(i-1+shift) % p + 1]
				):concat()
				if shifted == sofar.expanded:concat() then return true end
			end
		end)	

		allSoFar:insert{
			offsets = table(offsets),
			expanded = table(expanded),
		}

		print(
			'order #'..#allSoFar,
			offsets:concat' ',
			expanded:concat' ',
			found and ('translation isomorphic to '..found)
			or foundRev and ('translation reversed isomorphic to '..foundRev)
			or ''
		)
		if once then
			print'found'
			return
		end
	end

--print'performing iteration...'
	for i=n,1,-1 do
--print(tolua(o))
		o[i] += 1
		-- make sure all proceeding/more-nested iterations start at o[i]
		-- i.e. make sure o[1] = 0, o[i-1] <= o[i] <= p-1
		for j=i+1,n do
			o[j] = math.max(o[j], o[i])
		end
		if o[i] <= omax[i] then break end -- iteration worked. stop.
		-- now we want to inc the preceding o ... and then inc all subsequent ... 
		o[i] = 0
		if i == 1 then return end
	end
--print(tolua(o))
--print'...done performing iteration'
end
