#!/usr/bin/env rua

-- largest 2-binomial coefficient ... plus 1
local number = require 'ext.number'
number.base = 36
number.__tostring = number.tostring
-- assigning concat doesn't matter when concat a string and number ... you have to explicitly call tostring() ... builtin string __concat must not call number's tostring() ...
--number.__concat = string.concat
--number.__concat = |a,b| tostring(a)..tostring(b)

local CayleyDickson = require 'cayley-dickson'

local mod1 = |x, p| ((x-1) % p + 1)		-- modulo of 1-based indexes

local tablesAreEqual = |a,b| do
	if #a ~= #b then return false end
	for i=1,#a do
		if a[i] ~= b[i] then return false end
	end
	return true
end

local c = CayleyDickson(4)
print(c)

local es = table(c[1])
es:remove(1)

local shortname = |e| ((e.negative and '-' or '') .. tostring(e.index))

-- TODO TODO TODO try reindexing by searching for sub-octonions in-order then searching sub-quaternions of each sub-octonion in-order
print'quaternions:'
local allQuats = c:getTriplets()
for i,q in ipairs(allQuats) do
	print('q'..tostring(i)..' = ('..table.mapi(q, |e|
		--tostring(e) -- base-10
		'e'..tostring(e.index) -- base-whatever
	):concat', '..')')
end

local getQuaternionTriplets = |e| do
	local qs = table()
	for _,q in ipairs(allQuats) do
		for j=1,#q do
			if q[j].index == e.index then
				if e.negative then
					qs:insert(table{
						-q[j],
						q[mod1(j+2,3)],
						q[mod1(j+1,3)],
					})
				else
					qs:insert(table{
						q[j],
						q[mod1(j+1,3)],
						q[mod1(j+2,3)],
					})
				end
				break
			end
		end
	end
	return qs
end

-- find the quaternion index
-- returns the index and the original-stored quat (in case you are searching for a permutation of the original)
-- I'm sure I have this same function below somewhere....
local qFindIndex = |q| do
	local qeindexes = table.mapi(q, |e| e.index):sort()
	return allQuats:find(nil, |q2|
		tablesAreEqual(qeindexes, table.mapi(q2, |e| e.index):sort())
	)
end

local q_e_name = |q| do
	-- shows #s of es, no separator so only good if they are 1 digit long
	--return q:mapi(shortname):concat''

	-- same but put the quat index first as well
	return 'q'..tostring(qFindIndex(q))
		..'=e'..table.mapi(q, shortname):concat''
end

print()
print('per each basis, list of quaternions containing it:')
for i,e in ipairs(es) do
	io.write('e'..shortname(e)..':')
	for _,q in ipairs(getQuaternionTriplets(e)) do
		--io.write(' '..q_e_name(q))
		io.write(' q'..tostring(qFindIndex(q)))
	end
	print()
end


-- this is supposed to be the map from (ei,ej) to q=(ei,ej,ei*ej)
local quatMap = table()
for i,ei in ipairs(es) do
	quatMap[i] = table()
	for j,ej in ipairs(es) do
		if i ~= j then
			local ek = ei * ej
			--[[
			local qindex, q = allQuats:find(nil, |q|
				((table.find(q, nil, |qi| qi.index == ek.index)))
			)
			--]]
			local _,q = qFindIndex{ei,ej,ek}
			quatMap[i][j] = q
		end
	end
end

print()
print'quaternion containing ei, ej, ei*ej:'
for i,ei in ipairs(es) do
	print(range(#quatMap[1]):mapi(|j| do
		local qij = quatMap[i][j]
		return qij and 'q'..tostring(qFindIndex(qij)) or '..'
	end):concat' ')
end

print()
print'elements of quaternion containing ei,ej,ei*ej:'
for i,ei in ipairs(es) do
	print(range(#quatMap[1]):mapi(|j| do
		local qij = quatMap[i][j]
		return qij
			--and table.map(qij, |e| e.index):concat()
			--and table.map(qij, shortname):concat()
			and q_e_name(qij)
			or '.......'
	end):concat' ')
end

print()
print('unique mobius octonions in sedenions:')
-- offsets of indexes to form quaternions within the mobius strip
local quaternionInOctonionOffsets = table{0,1,3}
local fillMobius = |offsets, getSub, ...|do
	local initM = table{...}
	return coroutine.wrap(||do
		local recurse
		recurse = |m|do
			for i=1,math.huge do
				if not m[i+offsets[1]] then
					for _,e in ipairs(es) do
						m[i+offsets[1]] = e
						recurse(table(m))
					end
					return
				elseif not m[i+offsets[2]] then
					for _,t in ipairs(getSub(m[i+offsets[1]])) do
						if not m:find(nil, |t2| t2.index == t[2].index) then
							m[i+offsets[2]] = t[2]
							recurse(table(m))
						end
					end
					return
				else
					for k=3,#offsets do
						if not m[i+offsets[k]] then
							-- TODO don't use mul ... use pre-stored sets ...
							local t3 = m[i+offsets[k-2]] * m[i+offsets[k-1]]
							for j=1,#m-offsets[k]-1 do
								if tablesAreEqual(m:sub(j,j+offsets[k]), m:sub(#m-offsets[k],#m)) then
									coroutine.yield(m:sub(1,#m-offsets[k]-1))
									return
								end
							end
							m[i+offsets[k]] = t3
							recurse(m)
							return
						end
					end
				end
			end
		end
		recurse(table(initM))
	end)
end

local initM = table{...}:mapi(|i|do
	local neg = i:sub(1,1) == '-'
	if neg then i = i:sub(2) end
	i = assert(tonumber(i, 16))
	local e = assert(es[i])
	if neg then e = -e end
	return e
end)

local dontOmitIsomorphisms = false

local mobiusStrips = ||do
	local allOctonionsInSedenion = table()
	local uniqueset = {}
	for m in fillMobius(quaternionInOctonionOffsets, getQuaternionTriplets, initM:unpack()) do
		local key = m:mapi(|e| e.index):sort():concat'_'
		if dontOmitIsomorphisms or not uniqueset[key] then
			allOctonionsInSedenion:insert(m)
			uniqueset[key] = true
		end
	end
	return allOctonionsInSedenion
end

local allOctonionsInSedenion = mobiusStrips()
for i,m in ipairs(allOctonionsInSedenion) do
	print('o'..tostring(i)..': '..m:mapi(tostring):concat' ')
end

print()
print('number of unique mobius octonions in sedenions:', (#allOctonionsInSedenion):tostring(10))

-- now remove the trailing minus-parity octonions
local signAgnosticOctInSed = table(allOctonionsInSedenion):mapi(|o|
	table(o):mapi(|e| e.negative and -e or e)
)
for i=1,#signAgnosticOctInSed do
	local m = signAgnosticOctInSed[i]
	if #m == 14 then
		for j=1,7 do
			assert.eq(m[j+7].index, m[j].index)
		end
		m = table.sub(m, 1, 7)
		signAgnosticOctInSed[i] = m
	end
end

print()
print('unique octonions in sedenions, sign-agnostic:')
for i,o in ipairs(signAgnosticOctInSed) do
	print('o'..tostring(i)..': '..o:mapi(tostring):concat' ')
end

print()
print('quaternions within unique octonions in sedenions:')
for i,o in ipairs(signAgnosticOctInSed) do
	io.write('o'..tostring(i)..': ')
	-- follow the 1,2,4 spacing rule ... but if I wasn't then I wuold have to check every pair within the octonion.
	for j=1,#o do
		local qIndex = qFindIndex{o[mod1(j+0,#o)], o[mod1(j+1,#o)], o[mod1(j+3,#o)]}
		io.write(' q'..tostring(qIndex))
	end
	print()
end

-- now, with allOctonionsInSedenion ...
-- ... go through each quaternion of e's that are in quaternions of o's ...
print()
print('looking for quaternions of octonions that contain each quaternions of basis elements...')
print('...such that the subsequent has two in common with the previous...')
print('...and each quaternion of octonions should possess each element once, except the basis quaternion which appears 3 times')
do
	local findOctTripletContainingBasii = |i1, i2, i3|do
		local results = table()
		--[[ why is this running away when it works a few lines earlier?
		for m in fillMobius(quaternionInOctonionOffsets, getQuaternionTriplets, i1, i2, i3) do
			results:insert(table(m))
		end
		--]]
		-- [[
		for _,o in ipairs(signAgnosticOctInSed) do
			local ofs1 = table.find(o, nil, |e| e.index == i1)
			local ofs2 = table.find(o, nil, |e| e.index == i2)
			local ofs3 = table.find(o, nil, |e| e.index == i3)
			if ofs1 and ofs2 and ofs3 then
				if mod1(ofs2+1, #o) == ofs1 then
					-- reversed
					assert.len(o, 7)
					o = {
						o[mod1(ofs1+0, 7)],
						o[mod1(ofs1+6, 7)],
						o[mod1(ofs1+5, 7)],	-- \
						o[mod1(ofs1+2, 7)], -- |- these two are interchangeable
						o[mod1(ofs1+1, 7)], -- /
						o[mod1(ofs1+3, 7)], -- \_ these two are interchangeable
						o[mod1(ofs1+4, 7)], -- /
					}
					ofs1 = 1
					ofs2 = 2
					ofs3 = 4
				elseif mod1(ofs2+2, #o) == ofs1 then
					o = {
						o[mod1(ofs1+0, 7)],
						o[mod1(ofs1+5, 7)],
						o[mod1(ofs1+6, 7)],
						o[mod1(ofs1+4, 7)],
						o[mod1(ofs1+1, 7)],
						o[mod1(ofs1+3, 7)],
						o[mod1(ofs1+2, 7)],
					}
					ofs1 = 1
					ofs2 = 2
					ofs3 = 4
				elseif mod1(ofs2+3, #o) == ofs1 then
					o = {
						o[mod1(ofs1+0, 7)],
						o[mod1(ofs1+4, 7)],
						o[mod1(ofs1+6, 7)],
						o[mod1(ofs1+5, 7)],
						o[mod1(ofs1+3, 7)],
						o[mod1(ofs1+1, 7)],
						o[mod1(ofs1+2, 7)],
					}
					ofs1 = 1
					ofs2 = 2
					ofs3 = 4
				end
				if mod1(ofs1+1, #o) ~= ofs2 then
					error("idk this order "..tolua{ofs1=ofs1, ofs2=ofs2, ofs3=ofs3}..' for '..o:mapi(shortname):concat' ')
				end
				results:insert(range(#o):mapi(|i| o[mod1(i + ofs1-1, #o)]))
			end
		end
		--]]
		return results
	end

	local startIndexes = table{1,2,3}
	local searchOffsets = table{1,2,4}	-- 1,2,4 == spacing

	local searchForBasisIndexes, sedTriplet
	searchForBasisIndexes = startIndexes
	sedTriplet = findOctTripletContainingBasii(searchForBasisIndexes:unpack())

	print()
	print('quaternion containing '..searchForBasisIndexes:concat' ')
	-- TODO print the o index as well.
	for _,o in ipairs(sedTriplet) do
		print(' '..o:mapi(shortname):concat' ')
	end

	for iter=1,6 do
		searchForBasisIndexes = searchOffsets:mapi(|i| sedTriplet[1][i+1].index)
		sedTriplet = findOctTripletContainingBasii(searchForBasisIndexes:unpack())
		print('quaternion containing '..searchForBasisIndexes:concat' ')
		for _,o in ipairs(sedTriplet) do
			print(' '..o:mapi(shortname):concat' ')
		end
	end
end



--[[ TODO fill sedenion mobius ...
local octonionInSedenionOffsets = {0, 1, 2, 4, 5, 8, 10}
local getSubOctonions = |e| do
	local ts = table()
	for _,t in ipairs(allOctonionsInSedenion) do
		for j=1,7 do
			if t[j].index == e.index then
				ts:insert(table{
					t[j],
					t[j%7+1],
					t[(j+1)%7+1],
					t[(j+2)%7+1],
					t[(j+3)%7+1],
					t[(j+4)%7+1],
					t[(j+5)%7+1],
				})
				break
			end
		end
	end
	return ts
end

for m in fillMobius(octonionInSedenionOffsets, getSubOctonions, 1, 2, 4, 3) do
	print(m:concat' ')
end
--]]
--[[
1 2 4 . 3 6 . . 7 . 5 . . . .
1 2 8 . 3 A . . B . 9 . . . .
1 2 E . 3 C . . D . F . . . .
1 4 8 . 5 C . . D . 9 . . . .
1 4 A . 5 E . . F . B . . . .
1 7 8 . 6 F . . E . 9 . . . .
1 7 C . 6 B . . A . D . . . .
2 4 8 . 6 C . . E . A . . . .
2 4 9 . 6 D . . F . B . . . .
2 5 8 . 7 D . . F . A . . . .
2 5 C . 7 9 . . B . E . . . .
3 4 8 . 7 C . . F . B . . . .
3 4 9 . 7 D . . E . A . . . .
3 6 8 . 5 E . . D . B . . . .
3 6 C . 5 A . . 9 . F . . . .


1 2 4 . 3 6 . . 7 . 5 . . . .
  2 4 8 . 6 C . . E . A . . . .
    ... no more
  2 4 9 . 6 D . . F . B . . . .
    ... no more

1 2 8 . 3 A . . B . 9 . . . .
  ... no more

1 2 E . 3 C . . D . F . . . .
  ... no more

1 4 8 . 5 C . . D . 9 . . . .
  4 8 6 . C E . . A . 2 . . . .
    ... no more
  4 8 7 . C F . . B . 3 . . . .
    ... no more

1 4 A . 5 E . . F . B . . . .
  ... no more

1 7 8 . 6 F . . E . 9 . . . .
  ... no more

1 7 C . 6 B . . A . D . . . .
  7 C F . B 3 . . 4 . 8 . . . .
  ... no more

2 4 8 . 6 C . . E . A . . . .
  4 8 5 . C D . . 9 . 1 . . . .
    ... no more
  4 8 7 . C F . . B . 3 . . . .
    ... no more

2 4 9 . 6 D . . F . B . . . .
  4 9 6 . D F . . B . 2 . . . .
    ... no more
  4 9 7 . D E . . A . 3 . . . .
    ... no more

2 5 8 . 7 D . . F . A . . . .
  ... no more

2 5 C . 7 9 . . B . E . . . .
  5 C D . 9 1 . . 4 . 8 . . . .
    ... no more

3 4 8 . 7 C . . F . B . . . .
  4 8 5 . C D . . 9 . 1 . . . .
    ... no more
  4 8 6 . C E . . A . 2 . . . .
    ... no more

3 4 9 . 7 D . . E . A . . . .
  4 9 6 . D F . . B . 2  . . . .
    ... no more

3 6 8 . 5 E . . D . B . . . .
  ... no more

3 6 C . 5 A . . 9 . F . . . .
  6 C E . A 2 . . 4 . 8 . . . .
    ... no more


hmmmm this spacing and these subsets produce nothing.
maybe I need to swap dif indexes to make it work, not just 6 and 7?
--]]
