#!/usr/bin/env rua
local ForceDirectedGraph = require 'force-directed-graph'
local CayleyDickson = require 'cayley-dickson'

local useEdgesBetweenQuatBasis = false	-- if this is true, it just makes a dense graph among all basis elements
local useQuaternionNodes = true

local m = assert(tonumber(... or 2), "expected <n>")
local c = CayleyDickson(m)
print(c)
local n = #c-1

-- e[1]..e[n] = e1..en (excluding e0)
local e = table(c[1]):sub(2)

-- build 'sparseWeights[from][to]' then use it to build 'weights'
local sparseWeights = table()

local addBiDirWeight = |i,j|do
	sparseWeights[i] = sparseWeights[i] or table()
	sparseWeights[i][j] = 1
	sparseWeights[j] = sparseWeights[j] or table()
	sparseWeights[j][i] = 1
end

-- make nodes for all basis elements
local nodes = range(n):mapi(|i| 'e'..i)

-- make nodes for all quaternions
local qForSig = table()
local qs = table()
for i=1,n-1 do
	for j=i+1,n do
		local k = (e[i] * e[j]).index
		local qsig = table{i,j,k}:sort():concat','
		if not qForSig[qsig] then
			local q = 'q'..(#qs+1)..'=e'..qsig
			qForSig[qsig] = q

			if useQuaternionNodes then
				qs:insert(q)
				nodes:insert(q)
				addBiDirWeight(i, #nodes)
				addBiDirWeight(j, #nodes)
				addBiDirWeight(k, #nodes)
			end
		end

		if useEdgesBetweenQuatBasis then
			addBiDirWeight(i, j)
			addBiDirWeight(i, k)
			addBiDirWeight(j, k)
		end
	end
end

--[[
-- now link from each node to its respective triplet
-- TODO how to deduce this automatically. .. its in another script ...
if m == 3 then
	local addQuat = |q,a,b,c| do
		weights[a][7+q] = 1
		weights[b][7+q] = 1
		weights[c][7+q] = 1
	end
	addQuat(1, 1,2,3)
	addQuat(2, 1,4,5)
	addQuat(3, 1,7,6)
	addQuat(4, 2,4,6)
	addQuat(5, 2,5,7)
	addQuat(6, 3,4,7)
	addQuat(7, 3,6,5)
end
--]]

local weightFunc = |i,j| sparseWeights[i]?[j] or 0
print(require 'matrix'{#nodes,#nodes}:lambda(weightFunc))

local app = ForceDirectedGraph{
	nodes = nodes,
	weights = weightFunc,
}
return app:run()
