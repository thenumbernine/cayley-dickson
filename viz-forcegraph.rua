#!/usr/bin/env rua
local ForceDirectedGraph = require 'force-directed-graph'
local CayleyDickson = require 'cayley-dickson'
require 'vec-ffi'

-- CLI options:

local m = assert(tonumber(... or 2), "expected <n>")

-- if two e's have a q in common then put an edge between the e's
-- if this is true, it just makes a dense graph among all basis elements
local useEdges_e_to_e_in_q = cmdline.useEdges_e_to_e_in_q ?? false

-- if two e's have a q in common then put an edge from the e to the q
-- only show quats if we're viewing greater than quats
local useEdges_e_to_q = cmdline.useEdges_e_to_q ?? m >= 3

-- add the e's indexes to the q's name
local showEsInQsName = cmdline.showEsInQsName ?? false


local useEdges_e_to_e_in_o = cmdline.useEdges_e_to_e_in_o ?? false

-- only show octs if we are viewing greater than octs
local useEdges_e_to_o = cmdline.useEdges_e_to_o ?? m >= 4

local useEdges_q_to_o = cmdline.useEdges_q_to_o ?? m >= 4

local showEsInOsName = cmdline.showEsInOsName ?? false




local c = CayleyDickson(m)
print(c)
local n = #c-1

-- e[1]..e[n] = e1..en (excluding e0)
local e = table(c[1]):sub(2)

-- build 'sparseWeights[from][to]' then use it to build 'weights'
local sparseWeights = table()

-- make nodes for all basis elements
local nodes = table() 
local nodeIndexForIdent = {}


local addBiDirWeight = |i,j|do
--print(nodes[i].name..' <-> '..nodes[j].name)
	sparseWeights[i] ??= table()
	sparseWeights[i][j] = 1
	sparseWeights[j] ??= table()
	sparseWeights[j][i] = 1
end


local makeOrFindBasis = |eIndex|do
	local eIndexStr = tostring(eIndex)
	local nodeIdent = 'e'..eIndexStr
	local eNodeIndex = nodeIndexForIdent[nodeIdent]
	local new
	if not eNodeIndex then
		new = true
		local nodeName = 'e'..eIndex
		nodes:insert{
			name = nodeName,
			color = vec3f(1,1,0),
		}
		eNodeIndex = #nodes
		nodeIndexForIdent[nodeIdent] = eNodeIndex
	end
	return eNodeIndex, new
end

if useEdges_e_to_q
or useEdges_e_to_o
or useEdges_e_to_e_in_q
or useEdges_e_to_e_in_o
then
	for i=1,n do
		makeOrFindBasis(i)
	end
end

local getQuatSeq = |i,j| do
	-- i,j is the start of our quaternion
	local k = c[i+1][j+1].index	-- same as (e[i] * e[j]).index
	return table{i,j,k}:sort()
end

-- make nodes for all quaternions
local qNames = table()	-- track unique count of qs for indexing qs
local makeOrFindQuat = |indexesOfEsInQ| do
	local eIndexStr = indexesOfEsInQ:concat','
	local nodeIdent = 'q'..eIndexStr
	local qNodeIndex = nodeIndexForIdent[nodeIdent]
	local new
	if not qNodeIndex then
		new = true
		local nodeName = 'q'..(#qNames+1)
		if showEsInQsName then
			nodeName ..= '=e'..eIndexStr
		end

		qNames:insert(nodeName)
		nodes:insert{
			name = nodeName,
			color = vec3f(1,0,1),
		}
		qNodeIndex = #nodes
		nodeIndexForIdent[nodeIdent] = qNodeIndex
	end

	return qNodeIndex, new
end

-- how to search ...
-- within octonions, searching upper-triangular preserves dual order
-- further, within sedenions, the order does not match.
-- if we searched lower-triangular then the order would match in sedeniosn but would not preserve dual order...
if useEdges_e_to_q or useEdges_e_to_e_in_q then
	for i=1,n-1 do
		for j=i+1,n do
			local indexesOfEsInQ = getQuatSeq(i,j)
			if useEdges_e_to_q then
				local qNodeIndex, new = makeOrFindQuat(indexesOfEsInQ)
				if new then
					for _,i1 in ipairs(indexesOfEsInQ) do
						addBiDirWeight(i1, qNodeIndex)
					end
				end
			end	
			if useEdges_e_to_e_in_q then
				for i1=1,#indexesOfEsInQ-1 do
					for j1=i1+1,#indexesOfEsInQ do
						addBiDirWeight(indexesOfEsInQ[i1], indexesOfEsInQ[j1])
					end
				end
			end
		end
	end
end

-- [[
-- TODO make nodes for sub-octonions ... if m>=3
-- ... which we can do by searching all pairs of quaternions ...
-- TODO make nodes for sedenions if m >= 4
-- find octonions ...

local getOctSeq = |i,j,k,l| do
	local oiset = {[i]=true, [j]=true, [k]=true, [l]=true}
	local indexesOfEsInO = table{i,j,k,l}:sort()
	-- add all the rest of pairs' products' indexes
	for i1=1,#indexesOfEsInO-1 do
		for j1=i1+1,#indexesOfEsInO do
			local k1 = c[indexesOfEsInO[i1]+1][indexesOfEsInO[j1]+1].index
			oiset[k1] = true
		end
	end
	-- by now we should have exactly 7
	indexesOfEsInO = table.keys(oiset):sort()
	assert.len(indexesOfEsInO, 7)
	return indexesOfEsInO
end

local oNames = table()
local makeOrFindOct = |indexesOfEsInO| do
	local eIndexStr = indexesOfEsInO:concat','
	local nodeIdent = 'o'..eIndexStr 
	local oNodeIndex = nodeIndexForIdent[nodeIdent]
	local new
	if not oNodeIndex then
		new = true
		local nodeName = 'o'..(#oNames+1)
		if showEsInOsName then
			nodeName ..= '=e'..eIndexStr
		end
		
		oNames:insert(nodeName)
		nodes:insert{
			name = nodeName,
			color = vec3f(0,1,1),
		}
		oNodeIndex = #nodes
		nodeIndexForIdent[nodeIdent] = oNodeIndex
	end

	return oNodeIndex, new
end

if useEdges_e_to_o
or useEdges_q_to_o
or useEdges_e_to_e_in_o
then
	for i=1,n-2 do
		for j=i+1,n-1 do
			local k = c[i+1][j+1].index
			for l=j+1,n do
				if k ~= l then
					-- i,j,k could be a sole quaternion if e[i]*e[j]=+-e[k]
					-- so use i,j,k,l to start our octonion search:
					local indexesOfEsInO = getOctSeq(i,j,k,l)
					if useEdges_e_to_o
					or useEdges_q_to_o
					then
						local oNodeIndex, new = makeOrFindOct(indexesOfEsInO)
						if new then
							if useEdges_e_to_o then
								for _,i1 in ipairs(indexesOfEsInO) do
									addBiDirWeight(i1, oNodeIndex)
								end
							end
							if useEdges_q_to_o then
								for i1=1,#indexesOfEsInO-1 do
									for j1=i1+1,#indexesOfEsInO do
										local indexesOfEsInQ = getQuatSeq(
											indexesOfEsInO[i1],
											indexesOfEsInO[j1]
										)
										local qNodeIndex = makeOrFindQuat(indexesOfEsInQ)
										addBiDirWeight(qNodeIndex, oNodeIndex)
									end
								end
							end
						end
					end
					if useEdges_e_to_e_in_o then
						for i1=1,#indexesOfEsInO-1 do
							for j1=i1+1,#indexesOfEsInO do
								addBiDirWeight(indexesOfEsInO[i1], indexesOfEsInO[j1])
							end
						end
					end
				end
			end
		end
	end
end
--]]


local weightFunc = |i,j| sparseWeights[i]?[j] or 0
--print(require 'matrix'{#nodes,#nodes}:lambda(weightFunc))

local app = ForceDirectedGraph{
	nodes = nodes,
	weights = weightFunc,
}
return app:run()
