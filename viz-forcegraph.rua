#!/usr/bin/env rua
local ForceDirectedGraph = require 'force-directed-graph'
local CayleyDickson = require 'cayley-dickson'
require 'vec-ffi'

-- CLI options:

local m = assert(tonumber(... or 2), "expected <n>")

-- if two e's have a q in common then put an edge between the e's
-- if this is true, it just makes a dense graph among all basis elements
local useEdges_e_to_e_in_q = cmdline.useEdges_e_to_e_in_q ?? false

-- if two e's have a q in common then put an edge from the e to the q
-- only show quats if we're viewing greater than quats
local useEdges_e_to_q = cmdline.useEdges_e_to_q ?? m >= 3

-- add the e's indexes to the q's name
local showEsInQsName = cmdline.showEsInQsName ?? false


local useEdges_e_to_e_in_o = cmdline.useEdges_e_to_e_in_o ?? false

-- only show octs if we are viewing greater than octs
local useEdges_e_to_o = cmdline.useEdges_e_to_o ?? m >= 4

local useEdges_q_to_o = cmdline.useEdges_q_to_o ?? m >= 4

local showEsInOsName = cmdline.showEsInOsName ?? false




local c = CayleyDickson(m)
print(c)
local n = #c-1

-- e[1]..e[n] = e1..en (excluding e0)
local e = table(c[1]):sub(2)

-- build 'sparseWeights[from][to]' then use it to build 'weights'
local sparseWeights = table()

local addBiDirWeight = |i,j|do
	sparseWeights[i] ??= table()
	sparseWeights[i][j] = 1
	sparseWeights[j] ??= table()
	sparseWeights[j][i] = 1
end

-- make nodes for all basis elements
local nodes = range(n):mapi(|i| {
	name = 'e'..i,
	color = vec3f(1,1,0),
})

local nodeIndexForIdent = {}


local getQuatSeq = |i,j| do
	-- i,j is the start of our quaternion
	local k = c[i+1][j+1].index	-- same as (e[i] * e[j]).index
	local eIndexesInQ = table{i,j,k}:sort()
	return eIndexesInQ
end

-- make nodes for all quaternions
local qNames = table()	-- track unique count of qs for indexing qs
local makeOrFindQuat = |eIndexesInQ| do
	local eIndexStr = eIndexesInQ:concat','
	local nodeIdent = 'q'..eIndexStr
	local qNodeIndex = nodeIndexForIdent[nodeIdent]
	if not qNodeIndex then
		local nodeName = 'q'..(#qNames+1)
		if showEsInQsName then
			nodeName ..= '=e'..eIndexStr
		end

		qNames:insert(nodeName)
		nodes:insert{
			name = nodeName,
			color = vec3f(1,0,1),
		}
		qNodeIndex = #nodes
		nodeIndexForIdent[nodeIdent] = qNodeIndex
	end

	return qNodeIndex
end

-- how to search ...
-- within octonions, searching upper-triangular preserves dual order
-- further, within sedenions, the order does not match.
-- if we searched lower-triangular then the order would match in sedeniosn but would not preserve dual order...
if useEdges_e_to_q or useEdges_e_to_e_in_q then
	for i=1,n-1 do
		for j=i+1,n do
			local eIndexesInQ = getQuatSeq(i,j)
			if useEdges_e_to_q then
				local qNodeIndex = makeOrFindQuat(eIndexesInQ)
				for _,i1 in ipairs(eIndexesInQ) do
					addBiDirWeight(i1, qNodeIndex)
				end
			end	
			if useEdges_e_to_e_in_q then
				for i1=1,#eIndexesInQ do
					addBiDirWeight(
						eIndexesInQ[i1],
						eIndexesInQ[(i1 % #eIndexesInQ) + 1]
					)
				end
			end
		end
	end
end

-- [[
-- TODO make nodes for sub-octonions ... if m>=3
-- ... which we can do by searching all pairs of quaternions ...
-- TODO make nodes for sedenions if m >= 4
-- find octonions ...

local getOctSeq = |i,j,k,l| do
	local oiset = {[i]=true, [j]=true, [k]=true, [l]=true}
	local eIndexesInO = table{i,j,k,l}:sort()
	-- add all the rest of pairs' products' indexes
	for i1=1,#eIndexesInO-1 do
		for j1=i1+1,#eIndexesInO do
			oiset[c[eIndexesInO[i1]+1][eIndexesInO[j1]+1].index] = true
		end
	end
	-- by now we should have exactly 7
	eIndexesInO = table.keys(oiset):sort()
	assert.len(eIndexesInO, 7)
	return eIndexesInO
end

local oNames = table()
local makeOrFindOct = |eIndexesInO| do
	local eIndexStr = eIndexesInO:concat','
	local nodeIdent = 'o'..eIndexStr 
	local oNodeIndex = nodeIndexForIdent[nodeIdent]
	if not oNodeIndex then
		local nodeName = 'o'..(#oNames+1)
		if showEsInOsName then
			nodeName ..= '=e'..eIndexStr
		end
		
		oNames:insert(nodeName)
		nodes:insert{
			name = nodeName,
			color = vec3f(0,1,1),
		}
		oNodeIndex = #nodes
		nodeIndexForIdent[nodeIdent] = oNodeIndex
	end

	return oNodeIndex
end

if useEdges_e_to_o
or useEdges_q_to_o
or useEdges_e_to_e_in_o
then
	for i=1,n-2 do
		for j=i+1,n-1 do
			local k = c[i+1][j+1].index
			for l=j+1,n do
				if k ~= l then
					-- i,j,k could be a sole quaternion if e[i]*e[j]=+-e[k]
					-- so use i,j,k,l to start our octonion search:
					local eIndexesInO = getOctSeq(i,j,k,l)

					if useEdges_e_to_o
					or useEdges_q_to_o
					then
						local oNodeIndex = makeOrFindOct(eIndexesInO)
						if useEdges_e_to_o then
							for _,i1 in ipairs(eIndexesInO) do
								addBiDirWeight(i1, oNodeIndex)
							end
						end
					
						if useEdges_q_to_o then
							for i1=1,#eIndexesInO do
								local j1 = (i1 % #eIndexesInO) + 1
								local eIndexesInQ = getQuatSeq(
									eIndexesInO[i1],
									eIndexesInO[j1]
								)
								local qNodeIndex = makeOrFindQuat(eIndexesInQ)
								addBiDirWeight(qNodeIndex, oNodeIndex)
							end
						end
					end

					if useEdges_e_to_e_in_o then
						for i1=1,#eIndexesInO do
							addBiDirWeight(
								eIndexesInO[i1],
								eIndexesInO[(i1 % #eIndexesInO) + 1]
							)
						end
					end
				end
			end
		end
	end
end
--]]


local weightFunc = |i,j| sparseWeights[i]?[j] or 0
--print(require 'matrix'{#nodes,#nodes}:lambda(weightFunc))

local app = ForceDirectedGraph{
	nodes = nodes,
	weights = weightFunc,
}
return app:run()
