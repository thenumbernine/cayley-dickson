#!/usr/bin/env rua
require 'vec-ffi'
local Image = require 'image'
local gl = require 'gl'
local glnumber = require 'gl.number'
local GLSceneObject = require 'gl.sceneobject'
local GLGeometry = require 'gl.geometry'
local GLArrayBuffer = require 'gl.arraybuffer'
local GLTex2D = require 'gl.tex2d'
local GLHSVTex2D = require 'gl.hsvtex2d'
	
-- how many subscripts the textTex has ("e0" thru "e"...whatever)
local textTexMaxLetters = 16

local App = require 'imgui.appwithorbit'()
App.title = 'Octonion Multiplication Table'
App.viewDist = 2

local createIndexMapTex = |indexes| do
	print('creating texs for', tolua(indexes))
	return GLTex2D{
		image = Image(8, 1, 1, 'float', table(indexes):append{0}),
		internalFormat = gl.GL_R32F,
		minFilter = gl.GL_NEAREST,
		magFilter = gl.GL_NEAREST,
		wrap = {
			s = gl.GL_REPEAT,
			t = gl.GL_REPEAT,
		},
	}:unbind()
end

local mobiusUV = |u,v| do
	local r = vec3f(0, 0, v - .5)
	r = quatf():fromAngleAxis(0,1,0,180*u):rotate(r)
	r += vec3f(1,0,0)
	r = quatf():fromAngleAxis(0,0,1,360*u):rotate(r)
	return r
end

App.createMobius = |:, basisIndexes, vtxxform| do
	local xRes = 200
	local yRes = 10

	local vertexGPU = GLArrayBuffer{useVec=true, dim=3}:unbind()
	local texcoordGPU = GLArrayBuffer{useVec=true, dim=2}:unbind()
	local normalGPU = GLArrayBuffer{useVec=true, dim=3}:unbind()
	local vertexCPU = vertexGPU:beginUpdate()
	local texcoordCPU = texcoordGPU:beginUpdate()
	local normalCPU = normalGPU:beginUpdate()
	for j=0,yRes-1 do
		local v = j / (yRes-1)
		for i=0,xRes-1 do
			local u = i / (xRes-1)
			local r = mobiusUV(u,v)
			if vtxxform then r = vtxxform(r, u, v) or r end
			vertexCPU:emplace_back()[0] = r --:set( i / (xRes-1), j / (yRes-1) )
			texcoordCPU:emplace_back():set( i / (xRes-1), j / (yRes-1) )
		end
	end
	for j=0,yRes-1 do
		for i=0,xRes-1 do
			local iR = math.min(i+1,xRes-1) + xRes * j
			local iL = math.max(i-1,0)      + xRes * j
			local jR = i + xRes * math.min(j+1,yRes-1)
			local jL = i + xRes * math.max(j-1,0)
			local u = vertexCPU.v[iR] - vertexCPU.v[iL]
			local v = vertexCPU.v[jR] - vertexCPU.v[jL]
			normalCPU:emplace_back()[0] = u:cross(v):normalize()
		end
	end
	vertexGPU:endUpdate()
	texcoordGPU:endUpdate()
	normalGPU:endUpdate()

	local geometries = table()
	for j=0,yRes-2 do
		local indexes = table()
		for i=0,xRes-1 do
			for jofs=0,1 do
				indexes:insert(i + xRes * (j+jofs))
			end
		end
		geometries:insert{
			mode = gl.GL_TRIANGLE_STRIP,
			indexes = {
				data = indexes,
			},
		}
	end

	local mobiusObj = GLSceneObject{
		program = {
			version = 'latest',
			precision = 'best',
			vertexCode = [[
layout(location=0) in vec3 vertex;
layout(location=1) in vec2 texcoord;
layout(location=2) in vec3 normal;
out vec2 texcoordv;
out vec3 normalv;
uniform mat4 mvProjMat;

void main() {
	texcoordv = texcoord;
	normalv = normalize((mvProjMat * vec4(normal, 0.)).xyz);
	gl_Position = mvProjMat * vec4(vertex, 1.);
}

]],
			fragmentCode = [[
in vec2 texcoordv;
in vec3 normalv;

out vec4 fragColor;

uniform sampler2D textTex;
uniform sampler2D indexMapTex;

uniform sampler2D gradTex;
uniform vec2 gradRange;

#if 0
//  (0,1)
//       +---+---+
//       |\_               <- upper 1: y-1 = (0-1)/(3/2-0)(x-0) <=> y = 1 - 2*x/3
//       |\ \_     
//       | |  \            <- lower line: y-1 = (0-1)/(1/2-0)(x-0) <=> y = 1 - 2*x
//       +-+---+---+
//  (0,0)  ^   ^
//     (1/2,0) |
//           (3/2,0)
#endif

uniform float offset;

float mod1(float x) { return x - floor(x); }

float mapLetter(float u) {
	return texture(indexMapTex, vec2(mod1(u / 7.) * 7. / 8., .5)).r;
}

void main() {
	float u = texcoordv.x;
	float v = texcoordv.y;

	// determine septant here
	
	u *= .5;
	if (gl_FrontFacing) {
		u += .5;
		v = 1. - v;
	}
	u = mod1(u - offset);
	float gradU = u;
	u *= 7.;

	{
		vec2 tc;
		float len;
		float letter;
		
		letter = mapLetter(u - .5);

		tc = 5. * vec2(3. / 2. * mod1(u + .5 / 5. * 2. / 3.), v);
		len = length(tc - .5) / .5;
		if (len <= 1.) {
			if (len <= .95) {
				tc.x = 1. - tc.x;
				fragColor = texture(textTex, vec2((tc.x + letter) / ]]..glnumber(textTexMaxLetters)..[[, tc.y));
			} else { 
				fragColor = vec4(0.);
			}
			return;
		}
		
		letter = mapLetter(u + 3.);
		tc = 5. * vec2(3. / 2. * mod1(u - .5 + .5 / 5. * 2. / 3.), v - .8);
		len = length(tc - .5) / .5;
		if (len <= 1.) {
			if (len <= .95) {
				tc.x = 1. - tc.x;
				fragColor = texture(textTex, vec2((tc.x + letter) / ]]..glnumber(textTexMaxLetters)..[[, tc.y));
			} else {
				fragColor = vec4(0.);
			}
			return;
		}
	}

	float ix = floor(3./2.*v + u);
	float iy = floor(.5 * v + u);
	float ic = mod1(.5 * (ix + iy));

	if (ic != 0.) discard;

	fragColor = texture(gradTex, vec2(mix(gradRange.x, gradRange.y, gradU), .5));

	//apply diffuse lighting
	fragColor *= max(abs(normalv.z), .3);
}
]],
			uniforms = {
				offset = 0,
				textTex = 0,
				indexMapTex = 1,
				gradTex = 2,
				gradRange = {0,1},
			},
		},
		geometries = geometries,
		vertexes = vertexGPU,
		attrs = {
			texcoord = {
				buffer = texcoordGPU,
			},
			normal = {
				buffer = normalGPU,
			},
		},
		texs = {
			self.textTex,
			-- index-remapping
			createIndexMapTex(basisIndexes),
			self.gradTex,
		},
	}

	return mobiusObj
end


App.initGL = |:|do
	App.super.initGL(self)

	-- generated ... from font.png (TODO generate font.png from a system font)
	local fontSize = 48
	local fontImg = require 'gui.font':trueTypeToImage{size = fontSize}
	local textImg = Image(64 * textTexMaxLetters, 64, fontImg.channels, 'uint8_t'):clear()
	-- TODO additive-paste / alpha-paste
	local letterToRegion = |c| {
		x = ((c:byte() - 32) & 0xf) * fontSize,
		y = (((c:byte() - 32) >> 4) & 0xf) * fontSize,
		width = fontSize,
		height = fontSize,
	}
	for i=0,textTexMaxLetters-1 do
		textImg:pasteInto{x=64*i + 8, y=8, image=fontImg:copy(letterToRegion'e')} -- "e"
		textImg:pasteInto{x=64*i + 32, y=24, image=fontImg:copy(letterToRegion(i:hex())):resize(32, 32)} -- `i` from 0 to f (in hex)
	end	

	self.textTex = GLTex2D{
		image = textImg,
		minFilter = gl.GL_NEAREST,
		magFilter = gl.GL_LINEAR,
		wrap = {
			s = gl.GL_REPEAT,
			t = gl.GL_REPEAT,
		},
	}:unbind()

	self.gradTex = GLHSVTex2D(
		256, nil, true
--		minFilter = gl.GL_LINEAR_MIPMAP_LINEAR,
--		magFilter = gl.GL_LINEAR,
--		generateMipmap = true,
	):unbind()

	-- one possible mobius representation of quaternions-within-octonions
	--self.mobiusObj = self:createMobius{1,5,7,4,2,3,6}
	self.mobiusObj = self:createMobius{1,2,4,3,6,7,5}

	local sed = table{1, 2, 5, 8, 3, 7, 13, 11, 4, 10, 6, 15, 14, 12, 9}
	
	-- technicaly teh last two are reversed ... should I do that here?
	-- also, the spacing implies, I'm going to have to space out the vertexes in these mobius strips to get them to match up with one another
	local octInSedOffsets = table{0, 1, 8, 4, 10, 5, 2}

	self.octInSedIndexes = range(0,14):mapi(|i|
		octInSedOffsets:mapi(|j| sed[(i + j) % #sed + 1])
	)

	self.octMobiusObjs = self.octInSedIndexes:mapi(|indexes, i| do
		local mobiusObj = self:createMobius(indexes, |r, u, v| do
			-- plz make a continuous mapping that maps from
			-- for u*7 ...
			-- 0->0
			-- 1->1
			-- 2->8
			-- 3->4
			-- 4->10
			-- 5->5
			-- 6->2
		end)
		mobiusObj.uniforms.offset = (i-1)/#self.octInSedIndexes
		mobiusObj.uniforms.gradRange = {
			(i-1)/#self.octInSedIndexes,
			i/#self.octInSedIndexes,
		}
		return mobiusObj
	end)

	gl.glEnable(gl.GL_DEPTH_TEST)
	gl.glClearColor(.1, .1, .1, 1)
end

App.update = |:|do
	gl.glClear(gl.GL_COLOR_BUFFER_BIT | gl.GL_DEPTH_BUFFER_BIT)

	--[[ draw one mobius
	self.mobiusObj.uniforms.mvProjMat = self.view.mvProjMat.ptr
	self.mobiusObj.uniforms.offset = 0
	self.mobiusObj.uniforms.gradRange = {0,1}
	self.mobiusObj:draw()
	--]]
	-- [[ draw 7 mobiuses
	for i,mobiusObj in ipairs(self.octMobiusObjs) do
		self.view:setupModelView()	-- reset viewMat.  how about push/pop, or better, in View split mvMat into modelMat and viewMat?
		self.view.mvMat:applyRotate(i / #self.octMobiusObjs * 2 * math.pi, 0, 1, 0)
		self.view.mvMat:applyTranslate(4, 0, 0)
		self.view.mvProjMat:mul4x4(self.view.projMat, self.view.mvMat)
		
		mobiusObj.uniforms.mvProjMat = self.view.mvProjMat.ptr
		mobiusObj:draw()
	end
	--]]
	App.super.update(self)
end

return App():run()
